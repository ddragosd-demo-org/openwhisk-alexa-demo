In this exercise we will configure Alexa to handle requests for different metrics over any duration.

1. Add OneshotReportIntent to querySelectionHandlers

    'OneshotReportIntent': function () {
        //Oneshot Report Started
        console.log("OneshotReportIntent Started");
        
        //Get the intent object
        var intent = this.event.request.intent;
        
        //Pull out the duration from the oneshot report intent
        var duration = getDurationFromIntent(intent);
        
        //Pull out the metric from the oneshot report intent
        var metric = getMetricFromIntent(intent);
        
        //Based on the duration get the start and end dates
        var durationDates = DateUtil.getDurationFromToDates(duration);

        //Store local scope
        var that = this;

        //Get selected report suite
        var reportSuiteId = this.event.session.attributes.selectedReportSuite.rsid;

        console.log("Active report suite is " + reportSuiteId);

        //Call get metric using the information from the intent
        getMetric(this.event.session.user.accessToken, reportSuiteId, metric.metricId, durationDates, function metricResponseCallback(err, reportResponse) {
            //Response text
            var speechOutput;

            if (err) {
                //An error occured while trying to query metric
                speechOutput = that.t("API_ERROR");
                console.log("error" + JSON.stringify(err));
            } else {
                //A valid value for metric was returned
                console.log("report response:" + reportResponse);

                //Verb used to describe the metric based on duration. Past or present
                var verb = getDurationVerb(duration);

                //Get the measurement from the intent
                var measurement = getMeasurementFromIntent(intent);
                if(measurement == "percent"){
                    //The measurement is a percent, round to 2 decimal places and multiply by 100
                    speechOutput = "The " + metric.query + " " + duration + " " + verb + " " + (parseFloat(reportResponse).toFixed(2) * 100) + " " + measurement + ".";
                }else if(measurement.indexOf("pages") > -1){
                    //The measurement is pages, round to 2 decimal places
                    speechOutput = "The " + metric.query + " " + duration + " " + verb + " " + parseFloat(reportResponse).toFixed(2) + " " + measurement + ".";
                }else{
                    //All other metrics
                    speechOutput = "The total number of " + metric.query + " " + duration + " " + verb + " " + reportResponse;
                }
            }

            that.emit(':ask', speechOutput, that.t("QUERY_REPROMPT"));
        });
    },


2. Add getMeasurementFromIntent function

/**
 * Gets the measurement for the intent
 */
function getMeasurementFromIntent(intent) {
    console.log("Determining Intent Measurement");
    var metricSlot = intent.slots.Metric;
    var metricName = metricSlot.value;

    var metricValue = METRICS[metricName.toLowerCase()];
    var measurement = MEASUREMENT[metricValue];
    console.log("Measurement for " + metricValue + " is " + measurement);
    if (measurement) {
        return measurement;
    } else {
        return "";
    }
}

3. Add getDurationFromIntent function

/**
 * Gets the duration from the intent
 */
function getDurationFromIntent(intent) {
    var durationSlot = intent.slots.Duration;
    if (!durationSlot || !durationSlot.value) {
      return {
          duration: "today"
      }
    }

    return durationSlot.value;
}

4. Add getMetricFromIntent function.

/**
 * Gets the metric from the intent
 */
function getMetricFromIntent(intent) {
    var metricSlot = intent.slots.Metric;
    var metricName = metricSlot.value.toLowerCase();
    console.log("Metric is " + metricName + " which maps to " + METRICS[metricName]);
    if (METRICS[metricName]) {
        return {
            query: metricName,
            metricId: METRICS[metricName]
        }
    } else {
        return {
            error: true
        }
    }
}
